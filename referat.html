<!DOCTYPE html>
<html>
    <head>
        <title>HTTPS и HTTP - сигурност в PHP</title>
        <meta charset="UTF-8" />
        <link href="style.css" rel="stylesheet" />
        <script src="scripts.js"></script>
    </head>

    <body>
        <section id="container">
            <p>място за навигатора</p>
            <h1>HTTPS и HTTP - сигурност в PHP</h1>
            <article id="protocol">
                <h2>Какво е протокол?
                    <a class="refs" href="#1">[1]</a>
                </h2>
                <p>
                    Протоколът е набор от правила, които използваме за конкретни цели. 
                    В настоящия сценарий, когато говорим за протоколи, става въпрос за комуникация - начинът, 
                    по който говорим помежду си. Например, четец на новини говори на английски и тъй като разбираме английски, 
                    можем да разберем. Английският език е протоколът.
                    В момента, в който четецът на новини започне да говори на даден език, който не разбираме, протоколът престава да бъде полезен. 
                    Следователно е необходимо и двете страни да се съгласят с набор от правила, за да се осъществи комуникацията. 
                    Протоколът в този случай е за комуникация.
                    Сега, като говорим за мрежата, по-специфично, множество протоколи се използват за комуникация. 
                    Основно за крайните потребители най-важните и видими протоколи са HTTP и HTTPS. Въпреки че има и много други протоколи, 
                    HTTP и HTTPS протоколите обслужват по-голямата част от потребителите.
                </p>
            </article>
            
            <article id="http">
                <h2>Какво е HTTP протокол?</h2>
                <p>
                    HTTP е протокол за трансфер на хипертекст (Hyper Text Transfer Protocol). Просто казано - правила за изпращане и 
                    получаване на текстови съобщения. Както всички знаем, компютрите работят на език с азбука от 0 и 1, т.е. двоичен език. 
                    Следователно потенциално всеки набор или комбинация от 0 и 1 конструира дума в езика.
                    Да кажем, че искаме да напишем 'а'. Сега, ако 0 означава 'a', 1 означава 'b' и 01 означава 'c', можем да заключим, 
                    че комбинация от 0 и 1 също може да изгради дума. В този случай текстът вече е конструиран и се изпраща по кабела. 
                    Компютърът работи на много езици - чисти двоични, текстови и някои други формати като байт кодове. 
                    Тук това, което се прехвърля, е текст. Наблягаме на "текст", защото този текст се интерпретира от браузъра и в момента,
                    в който браузърът го интерпретира, той става хипертекст, а протоколът, който прехвърля текста, се нарича протокол за 
                    прехвърляне на хипертекст – HTTP.
                    Използвайки HTTP, можем да прехвърляме изображения и текст и дори звук, но не и видеоклипове.
                </p>
                <h3>Допълнителна информация за HTTP протокола
                    <a class="refs" href="#2">[2]</a>
                </h3>
                <p>
                    HTTP е основата на комуникацията на данни за World Wide Web и по-конкретно протокол на приложния слой, който работи върху други слоеве на стека от мрежови 
                    протоколи.
                    HTTP заявката е начинът, по който интернет комуникационните платформи, като например уеб браузърите, искат информацията, 
                    от която се нуждаят, за да заредят уебсайт. Всяка HTTP заявка, направена през интернет, носи със себе си поредица от 
                    кодирани данни, които носят различни видове информация. 
                   
                   <p>
                       Типична HTTP заявка съдържа: версия на HTTP, URL адрес, HTTP метод, HTTP хедъри на заявката, незадължително HTTP тяло
                   </p> 
                    
                    HTTP метод, показва действието, което HTTP заявката очаква от сървъра. Например, два от най-често срещаните HTTP методи са 
                    "GET" и "POST"; заявката "GET" очаква информация обратно в замяна, докато заявката "POST" обикновено показва, че клиентът 
                    изпраща информация към уеб сървъра.
                    HTTP хедърите съдържат текстова информация, съхранена в двойки ключ-стойност, и са част от всяка HTTP заявка.
                    Тялото на HTTP заявка съдържа всякаква информация, която се изпраща на уеб сървъра, като потребителско име и 
                    парола или всякакви други данни, въведени във формуляр.
                    HTTP отговорът е това, което уеб клиентите (често браузърите) получават от интернет сървър в отговор на HTTP заявка.
                    
                    <p>
                        Типичен HTTP отговор съдържа: HTTP код на състоянието, HTTP хедъри на отговора, незадължително HTTP тяло
                    </p>
                    
                    HTTP кодовете на състоянието са 3-цифрени кодове, които най-често се използват за указване дали дадена HTTP заявка е изпълнена успешно. 
                    Кодовете на състоянието са разделени на следните 5 блока:
                    
                    <p>    
                        1xx - информационен; 2xx - успех; 3xx - пренасочване; 4xx - клиентска грешка; 5xx - сървърна грешка ("xx" се отнася за 
                        различни числа между 00 и 99).
                    </p>
                    
                    Кодовете на състоянието, започващи с цифрата '2', показват успех. Например, след като клиент поиска уеб страница, най-често 
                    вижданите отговори имат код на състоянието "200 OK", което показва, че заявката е правилно изпълнена.
                    Ако отговорът започва с '4' или '5', това означава, че е имало грешка и уеб страницата няма да бъде показана. 
                    Код на състояние, който започва с '4', показва грешка от страна на клиента (много често се среща код на състояние 
                    "404 NOT FOUND", когато има правописна грешка в URL-а). Код на състоянието, започващ с '5', означава, че нещо се е объркало 
                    от страната на сървъра. Кодовете на състоянието също могат да започват с '1' или '3', което означава съответно информационен 
                    отговор и пренасочване.
                    Подобно на HTTP заявка, HTTP отговорът идва с хедъри, които предават важна информация като езика и формата на данните, 
                    които се изпращат в тялото на отговора.
                    Успешните HTTP отговори на заявки "GET" обикновено имат тяло, което съдържа исканата информация.
                </p>
                <h3>Dos/DDos атаки
                    <a class="refs" href="#2">[2]</a>,
                    DNS Spoofing
                    <a class="refs" href="#3">[3]</a>
                </h3>
                <p>
                    HTTP е протокол без състояние, което означава, че всяка команда се изпълнява независимо от всяка друга команда. 
                    В оригиналната спецификация всяка HTTP заявка създава и затваря TCP връзка. В по-новите версии на HTTP протокола (HTTP 1.1 и по-нови), 
                    постоянната връзка позволява множество HTTP заявки да преминават през постоянна TCP връзка, подобрявайки потреблението на ресурси. 
                    В контекста на DoS или DDoS атаки, HTTP заявки в големи количества могат да се използват като обект на атака към целево устройство и се 
                    считат за част от атаките на приложния слой или слой 7.
                </p>
                <p>
                    Клиентите, използващи HTTP, разчитат до голяма степен на услугата за имена на домейни и по този начин обикновено са склонни към атаки за сигурност, 
                    базирани на умишлено погрешно свързване с IP адреси и DNS имена. Така че клиентите трябва да бъдат внимателни при валидирането с IP номер/DNS име.
                    Ако HTTP клиентите кешират резултатите от търсенето на име на хост, за да постигнат подобрение на производителността, те трябва да спазват TTL информацията, 
                    докладвана от DNS. Ако HTTP клиентите не спазват това правило, те могат да бъдат подправени, когато IP адресът на предишния сървър се промени.
                </p>
            </article>

            <article id="https">
                <h2>Какво е HTTPS протокол?</h2>
                <p>
                    Hyper Text Transfer Protocol Secure (HTTPS) е защитената версия на HTTP, протоколът, по който данните се изпращат между 
                    браузъра и уебсайта, към който сме свързани. 'S' в края на HTTPS означава "защитено". Това означава, че всички комуникации 
                    между браузъра и уебсайта са криптирани. HTTPS често се използва за защита на силно поверителни онлайн транзакции като 
                    онлайн банкиране и формуляри за поръчки при онлайн пазаруване.
                </p>
                <h3>Допълнителна информация за HTTPS протокола
                    <a class="refs" href="#4">[4]</a>
                </h3>
                <p>
                    Всеки уебсайт, особено тези, които изискват идентификационни данни за вход, трябва да използва HTTPS. 
                    В съвременните уеб браузъри като Chrome уебсайтовете, които не използват HTTPS, са маркирани по различен начин от тези, 
                    които използват. Катинарът в URL лентата означава, че уеб страницата е защитена. Уеб браузърите приемат HTTPS сериозно; 
                    Google Chrome и други браузъри маркират всички не-HTTPS уебсайтове като несигурни.
                    HTTPS използва протокол за криптиране на комуникациите. Протоколът се нарича "Защита на транспортния слой" 
                    (Transport Layer Security (TLS)), въпреки че преди беше известен като "Слой със защитени сокети" (Secure Sockets Layer (SSL)).
                    Този протокол защитава комуникациите, като използва това, което е известно като инфраструктура с асиметричен публичен ключ. 
                    Този тип система за сигурност използва два различни ключа за криптиране на комуникацията между две страни:
                    
                    <p>
                        Частен ключ (private key) - този ключ се контролира от собственика на уебсайт и се пази. Този ключ се намира на уеб 
                        сървър и се използва за дешифриране на информация, криптирана от публичния ключ.
                    </p>
                    
                    Публичен ключ (public key) - този ключ е достъпен за всеки, който иска да взаимодейства със сървъра по начин, 
                    който е сигурен. Информацията, която е шифрована с публичния ключ, може да бъде декриптирана само с частен ключ.
                    
                    <p>
                        HTTPS не позволява на уебсайтовете да излъчват информацията си по начин, който лесно се вижда от всеки, който шпионира в мрежата. 
                        Когато информацията се изпраща през обикновен HTTP, информацията се разбива на пакети от данни, които могат лесно да бъдат "подушени" 
                        с помощта на безплатен софтуер. Това прави комуникацията през незащитена среда, като обществен Wi-Fi, силно уязвима за прихващане. 
                        Всъщност всички комуникации, които се осъществяват през HTTP, се извършват в обикновен текст, което ги прави изключително достъпни за 
                        всеки с правилните инструменти и уязвими на атаки по пътя.
                        С HTTPS трафикът е криптиран така, че дори пакетите да бъдат проучени или прихванати по друг начин, 
                        те ще се видят като безсмислени знаци. Да разгледаме един пример:
                    </p>
                    
                    Преди криптиране: <mark>This is a string of text that is completely readable</mark>
                    <p>
                        След криптиране: <mark>ITM0IRyiEhVpa6VnKyExMiEgNveroyWBPlgGyfkflYjDaaFf/Kn3bo3OfghBPDWo6AfSHlNtL8N7ITEwIXc1gU5X73xMsJormzzXlwOyrCs+9XCPk63Y+z0=</mark>
                    </p>
                    
                    В уебсайтове без HTTPS е възможно доставчици на интернет услуги или други посредници да инжектират съдържание в уеб страници 
                    без одобрението на собственика на уебсайта. Това обикновено е под формата на реклама, при която интернет доставчик, който иска да 
                    увеличи приходите, "инжектира" платена реклама в уеб страниците на своите клиенти. Не е изненадващо, че когато това се случи, печалбите от 
                    рекламите и контролът на качеството на тези реклами по никакъв начин не се споделят със собственика на уебсайта. 
                    HTTPS елиминира възможността на немодерирани трети страни да "инжектират" реклами в уеб съдържанието.
                    Технически погледнато, HTTPS не е отделен протокол от HTTP. Той просто използва TLS/SSL криптиране през HTTP протокола. HTTPS възниква въз 
                    основа на предаването на TLS/SSL сертификати, които потвърждават, че даден доставчик е този, за когото се представя.
                    Когато потребител се свърже с уеб страница, уеб страницата ще изпрати своя SSL сертификат, който съдържа публичния ключ, необходим за 
                    стартиране на защитената сесия. След това двата компютъра, клиентът и сървърът, преминават през процес, наречен SSL/TLS ръкостискане, 
                    който представлява поредица от комуникации напред-назад, използвани за установяване на защитена връзка. 
                    
                    <p>
                        Много доставчици на хостинг на уебсайтове и други услуги предлагат TLS/SSL сертификати срещу заплащане. 
                        Тези сертификати често се споделят между много клиенти. Предлагат се по-скъпи сертификати, които могат да бъдат индивидуално 
                        регистрирани за определени уеб свойства.
                    </p>
                </p>
            </article>

            <article id="ssl_tls">
                <h2>Разликата между SSL и TLS
                    <a class="refs" href="#5">[5]</a>
                </h2>
                <p>
                    Слой със защитени сокети (Secure Sockets Layer) & Защита на транспортния слой (Transport Layer Security)
                </p>
            
                SSL и TLS са криптографски протоколи, които осигуряват удостоверяване и криптиране на данни между сървъри, машини и приложения, 
                работещи в мрежа (напр. клиент, свързващ се с уеб сървър). В действителност SSL е само на около 25 години. Първата версия на SSL, 
                версия 1.0, била разработена за първи път през 1995 г. от Netscape, но никога не била пусната, тъй като била изпълнена със сериозни 
                пропуски в сигурността. SSL 2.0 не бил много по-добър, така че само година по-късно бил пуснат SSL 3.0, който отново имал сериозни 
                пропуски в сигурността.
                В този момент от Consensus Development разработили TLS 1.0. 
                TLS 1.0 бил невероятно подобен на SSL 3.0 – всъщност бил базиран на него – но все пак достатъчно различен, 
                за да изисква понижаване на версията, преди да може да се използва SSL 3.0.
                Понижаването до SSL 3.0 все още било опасно, като се имало предвид известните му уязвимости, които можели да се използват. 
                Всичко, което един атакуващ трябвало да направи, за да се насочи към уебсайт, било да понижи протокола до SSL 3.0. 
                Оттук се раждат атаките за понижаване на версията. Това в крайна сметка се оказва гвоздеят в ковчега за TLS 1.0.
                TLS 1.1 излиза седем години по-късно през 2006 г., заменен от TLS 1.2 през 2008 г. 
                Сега използваме TLS 1.3, който беше финализиран през 2018 г. TLS 1.3 прави значителни подобрения в сравнение с предшествениците 
                си. Microsoft, Apple, Google, Mozilla и Cloudflare обявиха планове за отхвърляне на TLS 1.0 и TLS 1.1 през януари 2020 г., 
                което направи TLS 1.2 и TLS 1.3 единствената алтернатива. (виж <a class="refs" href="#fig1">Фигура 1.</a>)
                
                <p>
                    Допълнителна информация за установяването на връзка между сървъра и клиента и нейното криптиране.
                    В началото на всяка връзка възниква процес, наречен ръкостискане. По време на този процес клиентът удостоверява TLS сертификата на сървъра и 
                    двамата решават за взаимно поддържан пакет от шифри. Пакетите за шифроване са колекция от алгоритми, които работят заедно, за да криптират 
                    сигурно връзката с този уебсайт. Когато пакетът от шифри се договори по време на ръкостискането, тогава се определя версията на протокола и 
                    поддържащите алгоритми. Сертификатът само улеснява процеса.
                </p>

                Исторически е имало четири алгоритъма в пакет от шифри: размяна на ключове, цифров подпис, удостоверяване на съобщението, 
                алгоритъм за хеширане
                
                <p>
                    TSL и SSL протоколите използват различни методи за криптиране на връзките.
                </p>

                <figure class="fig" id="fig1">
                    <img class="img" src="./images/evolution.jpg" width="500" />
                    <figcaption>
                        Фигура 1. Изобразяване на разликата между различните SSL и TLS версии
                        <a class="refs" href="#5">[5]</a>
                    </figcaption>
                </figure>
            </article>

            <article id="csp">
                <h2>Какво е Политика за сигурност на съдържанието (Content-Security-Policy)?
                    <a class="refs" href="#6">[6]</a>
                </h2>
                <p>
                    Content-Security-Policy е името на хедъра на HTTP отговора, който модерните браузъри използват за подобряване на сигурността 
                    на документа (или уеб страницата). Хедъра Content-Security-Policy позволява да ограничаваме ресурси като JavaScript, 
                    CSS или почти всичко, което браузърът зарежда. Въпреки че се използва предимно като хедър на HTTP отговор, 
                    можете също да се приложи чрез мета таг.
                    CSP за първи път е проектиран да намали изпълненията на Cross Site Scripting (XSS) атаки, по-късните версии на 
                    спецификацията също защитават срещу други форми на атака като Click Jacking.
                </p>
            </article>
            
            <article id="stats">
                <h2>Статистически данни
                    <a class="refs" href="#7">[7]</a>
                </h2>
                <p>
                    Към януари 2021 г. 89% от уеб страниците, заредени през Google Chrome, са използвали HTTPS протокол.
                    Същите проценти идват осреднени от всички платформи през май 2021 г.
                    За сравнение през април 2015 г. HTTPS трафикът за всички платформи е бил средно 40%.
                    
                    <p>
                        93.2% от времето прекарано онлайн през Google Chrome е прекарано на HTTPS страници.
                        Отново се отнася за всички платформи и процентът е малко по-висок от предната статистика за
                        броя заредени страници през Chrome, което показва, че потребителите са по-склонни да напуснат
                        сайт веднага, ако разберат, че не е защитен.
                    </p>
                    
                    35.4% от некриптирания потребителски трафик към Google идва от мобилни устройства. Това е и най-голямата 
                    промяна в сравнение с последната година, когато над 70% от некриптирания трафик е бил от мобилни устройства.
                </p>
            </article>

            <article>
                <h2>Защо HTTPS протоколът e важен?</h2>
                <p>
                    Съгласихме се, че това, което се прехвърля от една точка до друга, е текст. За да разберем защо точно протоколът HTTPS, 
                    първо трябва да разберем как функционират Wi-Fi рутерите. Нека приемем, че сме на летище и се свързваме към Wi-Fi мрежа, която е 
                    чужда собственост. Сега, когато комуникираме през HTTP, текстът се прехвърля от техния рутер. И ако отидем на по-ниско ниво 
                    на рутера, можем удобно да проверим и прочетем текста, който се прехвърля. Може да има парола, с която да злоупотребим. 
                    Това е фундаментално несигурно и се нарича "man-in-the-middle" атака. (виж <a class="refs" href="#fig2">Фигура 2.</a>)
                    Сега, за да защитим данните си от подобни атаки, трябва да ги криптираме.
                </p>

                <figure class="fig" id="fig2">
                    <img class="img" src="./images/attack.png" width="600" />
                    <figcaption>
                        Фигура 2. Man-in-the-middle атака
                        <a class="refs" href="#1">[1]</a>
                    </figcaption>
                </figure>

                <p>
                    Всъщност, за да осъществят защитена връзка за потребителите, през 2014 г. Google инвестират много средства, 
                    за да осигурят, че техните услуги използват сигурно HTTPS криптиране по подразбиране.
                </p>
                <h2>Криптиране и нива на криптиране</h2>
                <p>
                    Криптирането е прикриване на информация. Има различни начини за това - 64-битово, 128-битово, 256-битово HTTPS криптиране.
                    128-битовото и 256-битовото криптиране са техники от високо ниво и е много трудно да се декриптират (декодират). В случая на HTTPS, когато данните се 
                    прехвърлят, човекът, извършващ "man in the middle" атака, може да разбере, че някакви данни се прехвърлят, но не може 
                    да извлече смислена информация, защото данните са криптирани. Браузърът може да ги дешифрира и покаже, а сървърът 
                    може да ги декриптира и използва за бъдещи транзакции.
                </p>
                <h2>Какво се случва, когато изпратим заявка към браузъра, за да отворим даден сайт?</h2> 
                <p>
                    Нека си представим, че има сървър, който се намира някъде и обслужва всички заявки за един домейн. 
                    Сега, когато напишем например "example.com", това е сървърът, към който се свързваме, от който взимаме данни, които изобразяваме в браузъра.
                    Нека си представим, че съществува сървър - машина/компютър, която е свързана към интернет с домейн "google.com". В момента, в който
                    направим заявка към този сървър, той ни връща данни, които се изобразяват в браузъра. 
                    Ако сме запазили снимка, тя ще се качи на тази машина. Сега, ако искаме да видим тази снимка, отиваме например на адрес 
                    "google.com/мypictures", което прехвърля картината от машината в браузъра, за да я изобрази.
                    Този процес не може да бъде завършен, ако не успеем да се свържем с тази конкретна машина. За да се случи това, 
                    всяка машина има адрес (IP адрес) и всеки домейн има IP карта. В момента, в който въведем URL адреса "google.com",
                    той преобразува това потребителско име в IP адрес и се свързва с рутера, за да достигне до тази конкретна услуга, свързана с този URL адрес.
                    След като достигне до сървъра, издава се заявка за това, което е необходимо, представена като "google.com/s=", което помага на потребителя 
                    да разбере направената от него заявка. В резултат на това сървърът му изпраща резултатите, които се изобразяват в браузъра.
                </p>
                <h2>Какво се случва, когато се изпрати заявка за URL адрес на уебсайт, който използва HTTP/HTTPS протокол?</h2>
                <p>Като първа стъпка работата на HTTP е да открие сървъра и след като комуникационният маршрут е установен, сървърът изпраща 
                    заявка до браузъра. Тази заявка може да бъде или в чиста форма, или в кодирана форма (HTTPS), която след това се изобразява от 
                    браузъра или се използва за друга цел.
                    Тъй като трябва да има измерване на този коефициент на трудност, ние тълкуваме, че колкото по-голям е броят на битовете, 
                    толкова по-трудно е дешифрирането. Това само увеличава нивото на сложност, което прави много трудно дешифрирането, 
                    но не и невъзможно.
                </p>
                <h2>Избор между HTTP и HTTPS</h2>
                <p>
                    Може би има дейности в интернет, които искаме да оставим публични и за тях можем да използваме HTTP.
                    Въпреки това, за поверителна, банкова и транснационална информация, HTTPS протоколът се е утвърдил като стандарт. (виж <a class="refs" href="#fig3">Фигура 3.</a>)
                    Не може да се отрече фактът, че поверителността си има цена. HTTPS заявките отнемат повече време за обработка
                    (при HTTP комуникацията се осъществява по-бързо заради липсата на криптиране и декриптиране).
                    Тъй като се нуждаят от повече време за обработка, сървърът, който използваме се нуждае от по-добър хардуер. 
                    Това също означава допълнителни разходи.
                </p>

                <figure class="fig" id="fig3">
                    <img src="./images/difference.jpg" width="600" />
                    <figcaption>
                        Фигура 3. Разликата между HTTP и HTTPS
                        <a class="refs" href="#1">[1]</a>
                    </figcaption>
                </figure>
            </article>

            <article id="php">
                <h2>Сигурност в PHP</h2>
                <h3>Въведение
                    <a class="refs" href="#8">[8]</a>
                </h3>
                <p>
                    PHP е мощен език и интерпретаторът, независимо дали е включен в уеб сървър като модул или се изпълнява като отделен двоичен CGI файл, 
                    може да осъществява достъп до файлове, да изпълнява команди и да отваря мрежови връзки на сървъра. Тези свойства правят всичко, което се 
                    изпълнява на уеб сървър, несигурно по подразбиране. PHP е проектиран специално да бъде по-сигурен език за писане на CGI програми от 
                    Perl или C и с правилен набор от опции за конфигуриране по време на компилиране и изпълнение и правилни практики за кодиране, 
                    той може да даде свобода и сигурност за програмиста. Тъй като има много различни начини за използване на PHP, има много опции за конфигурация, 
                    контролиращи поведението му. Голям избор от опции гарантира, че можем да използваме PHP за много цели, но също така означава, че има 
                    комбинации и сървърни конфигурации, които водят до несигурни настройки. PHP може да се използва за изграждане на цялостни 
                    сървърни приложения или може да се използва за прости включвания от страна на сървъра с малък риск в строго контролирана среда. 
                    <p>
                        Според данни на W3Techs от април 2019 г. 79% от уебсайтовете се захранват от PHP. 
                        Тъй като PHP е толкова популярен, сигурността е от съществено значение и броят на уязвимите PHP приложения е голям. Повечето PHP 
                        уеб приложения споделят части от код или скриптове с други уеб приложения. Ако се установи, че споделеният код е уязвим, всички приложения, 
                        които го използват, също са уязвими. <a class="refs" href="#9">[9]</a>
                    </p>
                </p>
                <h3>Причини за уязвимости
                    <a class="refs" href="#9">[9]</a>
                </h3>
                <p>
                    Повечето уязвимости са резултат от лоши навици за кодиране или липса на информираност за сигурността на PHP приложения сред разработчиците. 
                    Основната причина е фактът, че въведеното от потребителя се третира като надеждно. Когато пишете код, трябва да приложите две ключови процедури: 
                    валидиране и прочистване на нежелан код. Ако приложите и двете процедури за потребителски данни, гарантирате, че това, което се обработва и изпълнява, 
                    е валидно и отговаря на определени критерии. Трябва също така да се уверите, че изходните HTML данни са "избегнати"(escaped), така че да не се
                    изпълнява зловреден код, в случай че недоброжелател го инжектира в съдържанието. Ако следвате определени прости и основни процедури за всяка уеб страница, 
                    значително минимизирате възможността да бъдете изложени на критичен проблем със сигурността. Обектно-ориентираното програмиране играе главна 
                    роля в прилагането на процедурите за защита на PHP. Добре написан код за многократна употреба може значително да увеличи цялостната сигурност на 
                    системата. Той гарантира, че винаги се следва една и съща процедура за обработка на данни.
                </p>
                <h3>SQL инжекции в PHP</h3>
                <p>
                    SQL инжекция е една от най-опасните уязвимости на уеб приложенията. Постоянно е класиран като номер едно от OWASP и засенчва други уязвимости като 
                    Cross-site Scripting (XSS) или Cross-site Request Forgery (CSRF). Ако вмъкнете потребителски входни данни директно в SQL заявка (невалидирана), 
                    нападателят може да манипулира самата заявка. Те могат да я принудят да върне резултат, различен от очаквания. Успешна атака с SQL инжектиране 
                    може да доведе до нарушение на данните, което може да разкрие потребителски имена, пароли, имейл адреси, информация за кредитни карти и други 
                    лични данни. В някои случаи дори обикновена атака може да доведе до компрометиране на цял уеб сървър.
                </p>
                <p>
                    <b>Пример за незащитено парче код</b>
                    <code class="code" id="code1">
                      // Тук параметърът "article" се предава на заявката несигурно:
                            $articleid = $_GET['article'];
                            $query = "SELECT * FROM articles WHERE articleid = '$articleid'";
                        
                      // Злонамерен потребител може да изпрати специално създадена стойност, която ще бъде включена в SQL заявката, преди заявката да бъде изпълнена. 
                      // Например:
                            1'+union+select+1,version(),3'
                        
                      // Заявката вече изглежда така:
                            $query = "SELECT * FROM articles WHERE articleid = '1'+union+select+1,version(),3''";
                    </code>
                    <figcaption class="fig">
                        Код 1. Пример за незащитено парче код - SQL инжекция
                    </figcaption>
                    
                    <p>
                        Нападателят може да използва заявки, подобни на горния код, за да изброи всички таблици/колони на базата данни и да получи достъп до лична информация.
                        Решението на този проблем е да се използват параметризирани SQL заявки (подготвени оператори). Ако използвате параметризирани заявки, 
                        уведомявате базата данни коя част е заявката и коя са данните (въведени от потребителя), защото ги изпращате в две отделни заявки. 
                        Това елиминира възможността за смесване на въвеждане от потребителя и SQL заявката. 
                        Препоръчително е използването на библиотека за работа с бази от данни катo PHP Data Objects (PDO) - интерфейс за изпълнение на подготвени оператори в PHP скриптовете. PDO е включен във 
                        версия на PHP 5.1 и се предлага като PECL разширение в PHP 5.0. Не е достъпен за по-стари версии на PHP.
                        Избягвайте да използвате mysql и mysqli разширения във вашия PHP код. Те са отхвърлени/остарели, но все още често се използват и можете да 
                        пренапишете кода, използвайки PDO.
                    </p>
                    <b>Пример за защитено парче код</b>
                    <p>
                        В този примерен PHP файл не се подава директно user_id на заявката. Вместо това се замества с контейнер. Backend базата данни ще знае с какво да 
                        замени контейнера, когато се стартира функцията execute().
                    </p>
                    <code class="code" id="code2">
                        // 'user_id' не трябва да бъде празна стойност, трябва да бъде числова ст-ст и string с дължина по-малка от 5
                        if((!empty($_GET['user_id'])) && (is_numeric($_GET['user_id'])) && (mb_strlen($_GET['user_id']) &lt; 5)){

                            $servername = "localhost";
                            $username = "username";
                            $password = "password";
                            $database = "dbname"; 

                            // осъществяваме нова връзка със SQL сървъра, използвайки PDO
                            try { 
                                $conn = new PDO("mysql:host=$servername;dbname=$database", $username, $password);

                                // присвояваме ст-ст на променливата "$user_id"
                                $user_id = $_GET['user_id']; 

                                // подготвяме заявката и задаваме placeholder за "$user_id"
                                $sth = $conn->prepare('SELECT user_name, user_surname FROM users WHERE user_id=?');

                                // изпълняваме заявката като подаваме "$user_id" в масив
                                $sth->execute(array($user_id));

                                // взимаме всички съответстващи редове
                                $user = $sth->fetch();

                                // ако има съвпадение с потребител, извеждаме тяхната информация
                                if(!empty($user)) {
                                    echo "Welcome ".$user['user_name']." ".$user['user_surname']; 
                                } else {
                                    echo "No user found"; 
                                }

                                // затваряме връзката
                                $dbh = null; 
                            } catch(PDOException $e) {
                                echo "Connection failed."; 
                            }
                        } else {
                            echo "User ID not specified or invalid."; 
                        }
                    </code>
                    <figcaption class="fig">
                        Код 2. Пример за защитено парче код - предотвратяване на SQL инжекция
                    </figcaption>
                </p>
            </article>

            <article id="good_practice">
                <h3>Добри практики за сигурност в PHP
                    <a class="refs" href="#10">[10]</a>
                </h3>
                
                <p>
                    <b>1. Актуализация на PHP версията</b>
                </p>
                Важно е редовно да актуализирате вашата PHP версия, тъй като по-новите версии често съдържат корекции за известни проблеми 
                със сигурността. Ако не актуализирате вашата PHP версия до най-новата стабилна версия, недоброжелатели могат да използват тези 
                известни уязвимости в сигурността с по-стари версии.
                Освен това PHP ви позволява да изпробвате предварителни издания на стабилни версии. 
                Съветниците по сигурността обаче обезсърчават компаниите 
                да се ангажират с тестване на предварителни издания, тъй като те все още могат да съдържат неизвестни пропуски.

                <p>
                    <b>2. Защита от XSS атаки (Cross-site scripting)</b>
                </p>
                XSS атака, известна още като междусайтов скрипт, се отнася до непреднамереното изпълнение на отдалечен код от вашето уеб 
                приложение. Например, XSS атака може да възникне, когато вашето уеб приложение приеме въвеждане от потребителя и го отпечата 
                директно на уеб страницата. Всеки път, когато злонамерен потребител включи HTML, JavaScript или дори CSS частта, вашето уеб приложение 
                ще изпълни непряко съответния код.
                
                <code class="code" id="code3">
                    // Примерът по-долу включва формуляр, който приема въвеждане на данни от потребителя.
                        &lt;form action="form.php" method="post"&gt;
                            &lt;input type="text" name="message" value=""&gt;
                            &lt;input type="submit" name="submit" value="Submit message"&gt;
                        &lt;/form&gt;

                    // След това отпечатваме въведените данни директно на уеб страницата.
                        &lt;?php
                            echo $_POST["message"];
                        ?&gt;

                    // Сега злонамерен потребител може да вмъкне JavaScript по този начин. Например, потребителят може да включи таг на скрипт с 
                    // функция за предупреждение, която вашето уеб приложение ще изпълни.
                        &lt;script&gt;alert("Hacker was here")&lt;/script&gt;
                </code>
                <figcaption class="fig">
                    Код 3. Пример за cross-site scripting атака
                </figcaption>
                
                <p>
                    Горният таг на скрипта ще генерира просто предупредително съобщение в браузъра. Това може да не изглежда опасно, 
                    но злонамерен потребител може лесно да открадне чувствителни потребителски данни. За да избегнете cross-site scripting атака, 
                    уверете се, че избягвате всяко потребителско въвеждане, за да избегнете непряко изпълнение на код.
                </p>

                <p>
                    <b>3. Използване на предварително подготвени SQL изрази</b>
                </p>
                Често срещана грешка е директно вмъкване на въведени от потребителя данни в SQL оператор. Това оставя място за атаки с инжектиране 
                чрез SQL, при които потребителят може да прекъсне предвидената SQL заявка и да изпълни всяка заявка, която желае.
                <code class="code" id="code4">
                    // Например, заявката по-долу директно използва необработен потребителски вход в SQL заявката.
                        $users = mysql_query("SELECT * FROM `users` WHERE `id`='$_GET[id]'");
                    
                    // С предварително подготвени изрази въведените стойности се "избягват", без да се оставя място за атака чрез SQL инжектиране.
                    // Нека да разгледаме примера по-долу, който използва подготвен израз.
                        $stmt = $conn->prepare("INSERT INTO users (firstname, lastname) VALUES (?, ?)");
                        $stmt->bind_param("ss", $firstname, $lastname);
                </code>
                <figcaption class="fig">
                    Код 4. Избягване на необработен потребителски вход с предварително дефинирани SQL изрази 
                </figcaption>

                <p>
                    Обърнете внимание на първия параметър на функцията bind_param. Това казва на SQL заявката типа данни, които предавате. 
                    Тук параметрите за име и фамилия са от тип String. Това е допълнителна мярка за сигурност за валидиране на типа данни на входа.
                </p>
                
                <p>
                    <b>4. Валидиране на входните данни</b>
                </p>
                Винаги когато потвърждавате въвеждането от потребителя, когато приемате вход чрез поле за въвеждане, това гарантира, 
                че всяка част от данните има правилния тип и формат. Обикновено разработчиците използват регулярни изрази, за да потвърдят 
                формати на данни като дата на раждане или телефонен номер.
                Примерът по-долу проверява дали датата на раждане е във формат ГГГГ-ММ-ДД.
                <code class="code" id="code5">
                    $date="2012-09-12";
                    return (preg_match("/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$/", $date)); // true or false
                </code>
                <figcaption class="fig">
                    Код 5. Валидиране на формата на датата
                </figcaption>
                
                <p>
                    <b>5. Ограничаване на достъпа до директориите</b>
                </p>
                Функцията open_basedir ви позволява да ограничите файловете, до които PHP има достъп във вашата файлова система. 
                Ако зададете функцията open_basedir в корена на вашия проект, това означава, че тя може да има достъп само до файлове 
                в корена на проекта и надолу. В случай, че злонамерен потребител получи достъп до вашия сървър чрез PHP и се опита да 
                получи достъп до лични файлове като /etc/passwd, функцията open_basedir ще предотврати това.

                <p>
                    <b>6. Верифициране на SSL/TLS конфигурацията</b>
                </p>
                Всеки сървър трябва да има SSL сертификат за сигурно прехвърляне на файлове чрез HTTPS. 
                Въпреки това редовно проверявайте сървъра си за остарели SSL сертификати или слаби протоколи за шифриране.
                Често системните администратори забравят да актуализират SSL сертификатите, когато изтекат. 
                SSL сертификатът обаче помага на вашия уебсайт с по-добра защита срещу XSS атаки.

                <p>
                    <b>7. Използване на URL кодиране</b>
                </p>
                PHP позволява на разработчиците функцията urlencode за безопасно генериране на валидни URL адреси. 
                Според документацията на PHP, функцията е удобна, когато кодирате низ, който да се използва в част от заявка на URL.
                Представете си, че потребителското въвеждане се използва за генериране на URL адрес. В такъв случай можете да 
                използвате функцията urlencode(), за да генерирате безопасен такъв.
                <code class="code" id="code6">
                    &lt;?php
                        echo '&lt;a href="mylink?user=', urlencode($userID), '"&gt;';
                    ?&gt;
                </code>
                <figcaption class="fig">
                    Код 6. Генериране на безопасен URL адрес с функцията urlencode() 
                </figcaption>

                <p>
                    <b>8. Избягване на непряко включване на файлове</b>
                </p>
                Никога не използвайте наготово потребителския вход за пряк достъп до файл.

                <code class="code" id="code7">
                    // Примерът по-долу показва израз, който използва генериран от потребителя вход и позволява дистанционно включване на файл.

                        &lt;?php
                            $page = $_GET['location']
                            require($page . ".php");
                        ?&gt;

                    // Например, ако въведената локация съвпада с "home", навигираме потребителя до началната страница. Вижте примера по-долу, 
                    // който илюстрира if-else за навигиране на потребителя. Ако страницата не съществува, извеждаме страница за грешка.

                        &lt;?php
                            $page = $_POST['page'];
                            if ($page == "home") {
                                require("./pages/home.php");
                            } elseif ($page == "contact") {
                                require("./pages/contact.php");
                            } else {
                                require("./pages/error.php");
                            }
                        ?&gt;
                </code>
                <figcaption class="fig">
                    Код 7. Обработване на входни данни при включване на файлове
                </figcaption>
                <p>
                    Поуката от тези параграфи е да валидирате въведеното от потребителя. Непровереният потребителски вход често е в 
                    основата на проблем със сигурността. Обърнете внимание на проблеми със сигурността, като дистанционно включване на файлове, 
                    URL кодиране или XSS атака. Всички те се случват при невалиден потребителски вход.
                </p>
            </article>
            
            <section id="imgs">
                <h3>Списък с фигури</h3>
                <ul class="list">
                    <li>
                        <a class="refs" href="#fig1">Фигура 1.</a> Изобразяване на разликата между различните SSL и TLS версии
                        <a class="refs" href="#5">[5]</a>
                    </li>
                    <li>
                        <a class="refs" href="#fig2">Фигура 2.</a> Man-in-the-middle атака
                        <a class="refs" href="#1">[1]</a>
                    </li>
                    <li>
                        <a class="refs" href="#fig3">Фигура 3.</a> Разликата между HTTP и HTTPS
                        <a class="refs" href="#1">[1]</a>
                    </li>
                </ul>
            </section>

            <section id="codes">
                <h3>Списък с примерен програмен код</h3>
                <ul class="list">
                    <li><a class="refs" href="#code1">Код 1.</a> Пример за незащитено парче код - SQL инжекция
                        <a class="refs" href="#9">[9]</a></li>
                    <li><a class="refs" href="#code2">Код 2.</a> Пример за защитено парче код - предотвратяване на SQL инжекция
                        <a class="refs" href="#9">[9]</a></li>
                    <li><a class="refs" href="#code3">Код 3.</a> Пример за cross-site scripting атака
                        <a class="refs" href="#10">[10]</a></li>
                    <li><a class="refs" href="#code4">Код 4.</a> Избягване на необработен потребителски вход с предварително дефинирани SQL изрази
                        <a class="refs" href="#10">[10]</a></li>
                    <li><a class="refs" href="#code5">Код 5.</a> Валидиране на формата на датата
                        <a class="refs" href="#10">[10]</a></li>
                    <li><a class="refs" href="#code6">Код 6.</a> Генериране на безопасен URL адрес с функцията urlencode()
                        <a class="refs" href="#10">[10]</a></li>
                    <li><a class="refs" href="#code7">Код 7.</a> Обработване на входни данни при включване на файлове
                        <a class="refs" href="#10">[10]</a></li>
                </ul>
            </section>

            <section id="refs">
                <h3>Цитирана литература и препратки</h3>
                <ul class="list">
                    <li id="1">
                        <a class="refs" href="https://www.izooto.com/blog/understanding-http-https-protocols">[1]</a>
                        Ruchika Sharma, 
                        <a class="refs" href="https://www.izooto.com/blog/understanding-http-https-protocols">
                        Easy Understanding of Web Protocols - HTTP and HTTPS</a>, 
                        последна актуализация на 2022-11-01,
                        последно посетен на 2022-11-13.
                        <small>(*включително параграфи, към които няма пряка препратка)</small>
                    </li>
                    <li id="2">
                        <a class="refs" href="https://www.cloudflare.com/learning/ddos/glossary/hypertext-transfer-protocol-http/">[2]</a>
                        Cloudflare learning rubric, 
                        <a class="refs" href="https://www.cloudflare.com/learning/ddos/glossary/hypertext-transfer-protocol-http/">
                        What is HTTP?</a>,
                        последно посетен на 2022-11-13.
                    </li>
                    <li id="3">
                        <a class="refs" href="https://www.tutorialspoint.com/http/http_security.htm">[3]</a>
                        Tutorialspoint HTTP tutorial,
                        <a class="refs" href="https://www.tutorialspoint.com/http/http_security.htm">
                        HTTP - Security</a>,
                        последно посетен на 2022-11-13.
                    </li>
                    <li id="4">
                        <a class="refs" href="https://www.cloudflare.com/learning/ssl/what-is-https/">[4]</a>
                        Cloudflare learning rubric,
                        <a class="refs" href="https://www.cloudflare.com/learning/ssl/what-is-https/">
                        What is HTTPS?</a>,
                        последно посетен на 2022-11-13.
                    </li>
                    <li id="5">
                        <a class="refs" href="https://www.globalsign.com/en/blog/ssl-vs-tls-difference">[5]</a>
                        Julie Olenski,
                        <a class="refs" href="https://www.globalsign.com/en/blog/ssl-vs-tls-difference">
                        SSL vs TLS - What's the Difference?</a>,
                        публикувано на 2020-02-13,
                        последно посетен на 2022-11-13.
                    </li>
                    <li id="6">
                        <a class="refs" href="https://content-security-policy.com/">[6]</a>
                        Foundeo Inc. CSP site,
                        <a class="refs" href="https://content-security-policy.com/">
                        Content Security Policy (CSP) Quick Reference Guide</a>,
                        последно посетен на 2022-11-13.
                    </li>
                    <li id="7">
                        <a class="refs" href="https://webtribunal.net/blog/ssl-stats/#gref">[7]</a>
                        Nick Galov (Източник: Google’s Transparency Report),
                        <a class="refs" href="https://webtribunal.net/blog/ssl-stats/#gref">
                        SSL Statistics that Show Why Security Matters so Much</a>,
                        последна актуализация на 2022-04-06,
                        последно посетен на 2022-11-13.
                    </li>
                    <li id="8">
                        <a class="refs" href="https://www.php.net/manual/en/security.intro.php">[8]</a>
                        PHP Manual, Security - Introduction,
                        <a class="refs" href="https://www.php.net/manual/en/security.intro.php">
                        PHP Manual, Security - Introduction</a>,
                        последно посетен на 2022-11-14.
                    </li>
                    <li id="9">
                        <a class="refs" href="https://www.acunetix.com/websitesecurity/php-security-1/">[9]</a>
                        Acunetix by Invicti, PHP Security,
                        <a class="refs" href="https://www.acunetix.com/websitesecurity/php-security-1/">
                        PHP Security: SQL Injections</a>,
                        последно посетен на 2022-11-14.
                    </li>
                    <li id="10">
                        <a class="refs" href="https://blog.sqreen.com/top-10-security-best-practices-for-php/">[10]</a>
                        Michiel Mulders, Sqreen Blog,
                        <a class="refs" href="https://blog.sqreen.com/top-10-security-best-practices-for-php/">
                        Best Security Practices for PHP</a>,
                        публикувано на 2020-08-26,
                        последно посетен на 2022-11-14.
                    </li>
                </ul>
            </section>
        </section>
        
        <aside id="bar"></aside>

        <nav id="navigation">
            <a href="#protocol">Протокол</a>
            <a href="#http">HTTP</a>
            <a href="#https">HTTPS</a>
            <a href="#ssl_tls">SSL & TLS</a>
            <a href="#csp">CSP</a>
            <a href="#stats">Статистически данни</a>
            <a href="#php">Сигурност в PHP</a>
            <a href="#good_practice">Добри практики за сигурност в PHP</a>
            <a href="#imgs">Препратки</a>
        </nav>

        <footer id="footer">
            <p>Ивелин Пламенов Петров, ФН: 81974, 2022/23, реферат по Web технологии на тема: HTTPS и HTTP - сигурност в PHP</p>
        </footer>
    </body>
</html>